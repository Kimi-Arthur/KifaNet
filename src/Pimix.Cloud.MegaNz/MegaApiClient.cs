using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Threading;
using System.Web;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;

namespace CG.Web.MegaApiClient {
    public class MegaApiClient {
        const int ApiRequestAttempts = 10;
        static readonly TimeSpan ApiRequestDelay = TimeSpan.FromSeconds(5);

        public static int BufferSize = 8192;

        static readonly Uri BaseApiUri = new Uri("https://g.api.mega.co.nz/cs");
        static readonly Uri BaseUri = new Uri("https://mega.nz");

        readonly WebClient webClient;

        Node trashNode;
        string sessionId;
        byte[] masterKey;
        uint sequenceIndex = (uint) (uint.MaxValue * new Random().NextDouble());

        #region Constructors

        /// <summary>
        ///     Instantiate a new <see cref="MegaApiClient" /> object
        /// </summary>
        public MegaApiClient() {
            webClient = new WebClient();
        }

        #endregion

        #region Public API

        /// <summary>
        ///     Generate authentication informations and store them in a serializable object to allow
        ///     persistence
        /// </summary>
        /// <param name="email">email</param>
        /// <param name="password">password</param>
        /// <returns><see cref="AuthInfos" /> object containing encrypted data</returns>
        /// <exception cref="ArgumentNullException">email or password is null</exception>
        public static AuthInfos GenerateAuthInfos(string email, string password) {
            if (string.IsNullOrEmpty(email)) throw new ArgumentNullException("email");

            if (string.IsNullOrEmpty(password)) throw new ArgumentNullException("password");

            // Retrieve password as UTF8 byte array
            var passwordBytes = password.ToBytes();

            // Encrypt password to use password as key for the hash
            var passwordAesKey = PrepareKey(passwordBytes);

            // Hash email and password to decrypt master key on Mega servers
            var hash = GenerateHash(email.ToLowerInvariant(), passwordAesKey);

            return new AuthInfos(email, hash, passwordAesKey);
        }

        /// <summary>
        ///     Login to Mega.co.nz service using email/password credentials
        /// </summary>
        /// <param name="email">email</param>
        /// <param name="password">password</param>
        /// <exception cref="ApiException">Service is not available or credentials are invalid</exception>
        /// <exception cref="ArgumentNullException">email or password is null</exception>
        /// <exception cref="NotSupportedException">Already logged in</exception>
        public void Login(string email, string password) {
            Login(GenerateAuthInfos(email, password));
        }

        /// <summary>
        ///     Login to Mega.co.nz service using hashed credentials
        /// </summary>
        /// <param name="authInfos">
        ///     Authentication informations generated by <see cref="GenerateAuthInfos" />
        ///     method
        /// </param>
        /// <exception cref="ApiException">Service is not available or authInfos is invalid</exception>
        /// <exception cref="ArgumentNullException">authInfos is null</exception>
        /// <exception cref="NotSupportedException">Already logged in</exception>
        public void Login(AuthInfos authInfos) {
            if (authInfos == null) throw new ArgumentNullException("authInfos");

            EnsureLoggedOut();

            // Request Mega Api
            var request = new LoginRequest(authInfos.Email, authInfos.Hash);
            var response = Request<LoginResponse>(request);

            // Decrypt master key using our password key
            var cryptedMasterKey = response.MasterKey.FromBase64();
            masterKey = Crypto.DecryptKey(cryptedMasterKey, authInfos.PasswordAesKey);

            // Decrypt RSA private key using decrypted master key
            var cryptedRsaPrivateKey = response.PrivateKey.FromBase64();
            var rsaPrivateKeyComponents =
                Crypto.GetRsaPrivateKeyComponents(cryptedRsaPrivateKey, masterKey);

            // Decrypt session id
            var encryptedSid = response.SessionId.FromBase64();
            var sid = Crypto.RsaDecrypt(encryptedSid.FromMPINumber(), rsaPrivateKeyComponents[0],
                rsaPrivateKeyComponents[1], rsaPrivateKeyComponents[2]);

            // Session id contains only the first 58 base64 characters
            sessionId = sid.ToBase64().Substring(0, 58);
        }

        /// <summary>
        ///     Logout from Mega.co.nz service
        /// </summary>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        public void Logout() {
            EnsureLoggedIn();

            // Reset values retrieved by Login methods
            masterKey = null;
            sessionId = null;
        }

        /// <summary>
        ///     Retrieve account (quota) information
        /// </summary>
        /// <returns>An object containing account information</returns>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        public AccountInformationResponse GetAccountInformation() {
            EnsureLoggedIn();

            var request = new AccountInformationRequest();
            return Request<AccountInformationResponse>(request);
        }

        /// <summary>
        ///     Retrieve all filesystem nodes
        /// </summary>
        /// <returns>Flat representation of all the filesystem nodes</returns>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        public IEnumerable<Node> GetNodes() {
            EnsureLoggedIn();

            var request = new GetNodesRequest();
            var response = Request<GetNodesResponse>(request, masterKey);

            var nodes = response.Nodes;
            if (trashNode == null) trashNode = nodes.First(n => n.Type == NodeType.Trash);

            return nodes.Distinct().Cast<Node>();
        }

        /// <summary>
        ///     Delete a node from the filesytem
        /// </summary>
        /// <remarks>
        ///     You can only delete <see cref="NodeType.Directory" /> or <see cref="NodeType.File" /> node
        /// </remarks>
        /// <param name="node">Node to delete</param>
        /// <param name="moveToTrash">Moved to trash if true, Permanently deleted if false</param>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        /// <exception cref="ArgumentNullException">node is null</exception>
        /// <exception cref="ArgumentException">node is not a directory or a file</exception>
        public void Delete(Node node, bool moveToTrash = true) {
            if (node == null) throw new ArgumentNullException("node");

            if (node.Type != NodeType.Directory && node.Type != NodeType.File)
                throw new ArgumentException("Invalid node type");

            EnsureLoggedIn();

            if (moveToTrash)
                Move(node, trashNode);
            else
                Request(new DeleteRequest(node));
        }

        /// <summary>
        ///     Create a folder on the filesytem
        /// </summary>
        /// <param name="name">Folder name</param>
        /// <param name="parent">Parent node to attach created folder</param>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        /// <exception cref="ArgumentNullException">name or parent is null</exception>
        /// <exception cref="ArgumentException">
        ///     parent is not valid (all types are allowed expect
        ///     <see cref="NodeType.File" />)
        /// </exception>
        public Node CreateFolder(string name, Node parent) {
            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException("name");

            if (parent == null) throw new ArgumentNullException("parent");

            if (parent.Type == NodeType.File) throw new ArgumentException("Invalid parent node");

            EnsureLoggedIn();

            var key = Crypto.CreateAesKey();
            var attributes = Crypto.EncryptAttributes(new Attributes(name), key);
            var encryptedKey = Crypto.EncryptAes(key, masterKey);

            var request = CreateNodeRequest.CreateFolderNodeRequest(parent, attributes.ToBase64(),
                encryptedKey.ToBase64());
            var response = Request<GetNodesResponse>(request, masterKey);
            return response.Nodes[0];
        }

        /// <summary>
        ///     Retrieve a Stream to download and decrypt the specified node
        /// </summary>
        /// <param name="node">Node to download (only <see cref="NodeType.File" /> can be downloaded)</param>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        /// <exception cref="ArgumentNullException">node or outputFile is null</exception>
        /// <exception cref="ArgumentException">
        ///     node is not valid (only <see cref="NodeType.File" /> can be
        ///     downloaded)
        /// </exception>
        /// <exception cref="DownloadException">Checksum is invalid. Downloaded data are corrupted</exception>
        public Stream Download(Node node) {
            if (node == null) throw new ArgumentNullException("node");

            if (node.Type != NodeType.File) throw new ArgumentException("Invalid node");

            var nodeCrypto = node;
            if (nodeCrypto == null) throw new ArgumentException("node must implement Node");

            EnsureLoggedIn();

            // Retrieve download URL
            var downloadRequest = new DownloadUrlRequest(node);
            var downloadResponse = Request<DownloadUrlResponse>(downloadRequest);

            var dataStream = webClient.GetRequestRaw(new Uri(downloadResponse.Url));
            return new StreamWithLength(dataStream, downloadResponse.Size);
        }

        /// <summary>
        ///     Upload a stream on Mega.co.nz and attach created node to selected parent
        /// </summary>
        /// <param name="stream">Data to upload</param>
        /// <param name="name">Created node name</param>
        /// <param name="parent">
        ///     Node to attach the uploaded file (all types except
        ///     <see cref="NodeType.File" /> are supported)
        /// </param>
        /// <returns>Created node</returns>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        /// <exception cref="ArgumentNullException">stream or name or parent is null</exception>
        /// <exception cref="ArgumentException">
        ///     parent is not valid (all types except
        ///     <see cref="NodeType.File" /> are supported)
        /// </exception>
        public Node Upload(Stream stream, string name, Node parent) {
            if (stream == null) throw new ArgumentNullException("stream");

            if (string.IsNullOrEmpty(name)) throw new ArgumentNullException("name");

            if (parent == null) throw new ArgumentNullException("parent");

            if (parent.Type == NodeType.File) throw new ArgumentException("Invalid parent node");

            EnsureLoggedIn();

            // Retrieve upload URL
            var uploadRequest = new UploadUrlRequest(stream.Length);
            var uploadResponse = Request<UploadUrlResponse>(uploadRequest);

            var chunksPositions = GetChunksPositions(stream.Length);

            string completionHandle = null;
            for (var i = 0; i < chunksPositions.Length; i++) {
                var currentChunkPosition = chunksPositions[i];
                var nextChunkPosition = i == chunksPositions.Length - 1
                    ? stream.Length
                    : chunksPositions[i + 1];

                var chunkSize = (int) (nextChunkPosition - currentChunkPosition);
                var chunkBuffer = new byte[chunkSize];
                stream.Read(chunkBuffer, 0, chunkSize);
                using (var chunkStream = new MemoryStream(chunkBuffer)) {
                    var remainingRetry = ApiRequestAttempts;
                    string result = null;
                    UploadException lastException = null;
                    while (remainingRetry-- > 0) {
                        var uri = new Uri(uploadResponse.Url + "/" + chunksPositions[i]);
                        result = webClient.PostRequestRaw(uri, chunkStream);
                        if (result.StartsWith("-")) {
                            lastException = new UploadException(result);
                            Thread.Sleep(ApiRequestDelay);
                            continue;
                        }

                        lastException = null;
                        break;
                    }

                    if (lastException != null) throw lastException;

                    completionHandle = result;
                }
            }

            // Encrypt attributes
            var cryptedAttributes = Crypto.EncryptAttributes(new Attributes(name), new byte[16]);

            var encryptedKey = Crypto.EncryptKey(new byte[32], masterKey);

            var createNodeRequest = CreateNodeRequest.CreateFileNodeRequest(parent,
                cryptedAttributes.ToBase64(), encryptedKey.ToBase64(), completionHandle);
            var createNodeResponse = Request<GetNodesResponse>(createNodeRequest, masterKey);
            return createNodeResponse.Nodes[0];
        }

        /// <summary>
        ///     Change node parent
        /// </summary>
        /// <param name="node">Node to move</param>
        /// <param name="destinationParentNode">New parent</param>
        /// <returns>Moved node</returns>
        /// <exception cref="NotSupportedException">Not logged in</exception>
        /// <exception cref="ApiException">Mega.co.nz service reports an error</exception>
        /// <exception cref="ArgumentNullException">node or destinationParentNode is null</exception>
        /// <exception cref="ArgumentException">
        ///     node is not valid (only <see cref="NodeType.Directory" /> and
        ///     <see cref="NodeType.File" /> are supported)
        /// </exception>
        /// <exception cref="ArgumentException">
        ///     parent is not valid (all types except
        ///     <see cref="NodeType.File" /> are supported)
        /// </exception>
        public Node Move(Node node, Node destinationParentNode) {
            if (node == null) throw new ArgumentNullException("node");

            if (destinationParentNode == null)
                throw new ArgumentNullException("destinationParentNode");

            if (node.Type != NodeType.Directory && node.Type != NodeType.File)
                throw new ArgumentException("Invalid node type");

            if (destinationParentNode.Type == NodeType.File)
                throw new ArgumentException("Invalid destination parent node");

            EnsureLoggedIn();

            Request(new MoveRequest(node, destinationParentNode));
            return GetNodes().First(n => n.Equals(node));
        }

        #endregion

        #region Private static methods

        static string GenerateHash(string email, byte[] passwordAesKey) {
            var emailBytes = email.ToBytes();
            var hash = new byte[16];

            // Compute email in 16 bytes array
            for (var i = 0; i < emailBytes.Length; i++) hash[i % 16] ^= emailBytes[i];

            // Encrypt hash using password key
            for (var it = 0; it < 16384; it++) hash = Crypto.EncryptAes(hash, passwordAesKey);

            // Retrieve bytes 0-4 and 8-12 from the hash
            var result = new byte[8];
            Array.Copy(hash, 0, result, 0, 4);
            Array.Copy(hash, 8, result, 4, 4);

            return result.ToBase64();
        }

        static byte[] PrepareKey(byte[] data) {
            var pkey = new byte[] {
                0x93, 0xC4, 0x67, 0xE3, 0x7D, 0xB0, 0xC7, 0xA4, 0xD1, 0xBE, 0x3F, 0x81, 0x01, 0x52,
                0xCB, 0x56
            };

            for (var it = 0; it < 65536; it++)
            for (var idx = 0; idx < data.Length; idx += 16) {
                // Pad the data to 16 bytes blocks
                var key = data.CopySubArray(16, idx);

                pkey = Crypto.EncryptAes(pkey, key);
            }

            return pkey;
        }

        #endregion

        #region Web

        string Request(RequestBase request) => Request<string>(request);

        TResponse Request<TResponse>(RequestBase request, object context = null)
            where TResponse : class {
            var dataRequest = JsonConvert.SerializeObject(new object[] {request});
            var uri = GenerateUrl();
            object jsonData = null;
            var currentAttempt = 0;
            while (true) {
                var dataResult = webClient.PostRequestJson(uri, dataRequest);

                jsonData = JsonConvert.DeserializeObject(dataResult);
                if (jsonData is long || jsonData is JArray &&
                    ((JArray) jsonData)[0].Type == JTokenType.Integer) {
                    var apiCode = jsonData is long
                        ? (ApiResultCode) Enum.ToObject(typeof(ApiResultCode), jsonData)
                        : (ApiResultCode) ((JArray) jsonData)[0].Value<int>();

                    if (apiCode == ApiResultCode.RequestFailedRetry) {
                        if (currentAttempt == ApiRequestAttempts)
                            throw new NotSupportedException("Api not available");

                        Thread.Sleep(ApiRequestDelay);
                        currentAttempt++;
                        continue;
                    }

                    if (apiCode != ApiResultCode.Ok) throw new ApiException(apiCode);
                }

                break;
            }

            var settings = new JsonSerializerSettings();
            settings.Context = new StreamingContext(StreamingContextStates.All, context);

            var data = ((JArray) jsonData)[0].ToString();
            return typeof(TResponse) == typeof(string)
                ? data as TResponse
                : JsonConvert.DeserializeObject<TResponse>(data, settings);
        }

        Uri GenerateUrl() {
            var builder = new UriBuilder(BaseApiUri);
            var query = HttpUtility.ParseQueryString(builder.Query);
            query["id"] = (sequenceIndex++ % uint.MaxValue).ToString(CultureInfo.InvariantCulture);

            if (!string.IsNullOrEmpty(sessionId)) query["sid"] = sessionId;

            builder.Query = query.ToString();
            return builder.Uri;
        }

        void SaveStream(Stream stream, string outputFile) {
            using (var fs = new FileStream(outputFile, FileMode.CreateNew, FileAccess.Write)) {
                stream.CopyTo(fs, BufferSize);
            }
        }

        #endregion

        #region Private methods

        void EnsureLoggedIn() {
            if (sessionId == null) throw new NotSupportedException("Not logged in");
        }

        void EnsureLoggedOut() {
            if (sessionId != null) throw new NotSupportedException("Already logged in");
        }

        long[] GetChunksPositions(long size) {
            var chunks = new List<long>();
            chunks.Add(0);

            long chunkStartPosition = 0;
            for (var idx = 1; idx <= 8 && chunkStartPosition < size - idx * 131072; idx++) {
                chunkStartPosition += idx * 131072;
                chunks.Add(chunkStartPosition);
            }

            while (chunkStartPosition + 1048576 < size) {
                chunkStartPosition += 1048576;
                chunks.Add(chunkStartPosition);
            }

            return chunks.ToArray();
        }

        #endregion

        #region AuthInfos

        public class AuthInfos {
            public AuthInfos(string email, string hash, byte[] passwordAesKey) {
                Email = email;
                Hash = hash;
                PasswordAesKey = passwordAesKey;
            }

            [JsonProperty]
            public string Email { get; private set; }

            [JsonProperty]
            public string Hash { get; private set; }

            [JsonProperty]
            public byte[] PasswordAesKey { get; private set; }
        }

        #endregion
    }
}
